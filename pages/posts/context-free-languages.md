---
title: 'Context-Free Languages'
date: '2021-02-14'
---

## Context-Free Languages

### Context-Free Grammar (CFG)

$CFG = (V, \Sigma, R, S)$, where
1. $V$ is a finite set of variables
2. $\Sigma$ is a finite set of terminals
3. $R$ is a finite set of rules, with each rule being a variable and a string of variables and terminals
4. $S\in V$ is the start variable

Say $u$ derives $v$ (written $u \overset{*}{\Rightarrow} v$) if $u \Rightarrow u_1 \Rightarrow u_2 \Rightarrow ... \Rightarrow v$.
Suppose $D = (V, \Sigma, R, S)$ is a CFG. Then the language of D is
$$\{w \in \Sigma^* | S \overset{*}{\Rightarrow}w\}$$

A language is context free if it can be generated by some context free grammar
*Ambiguity*: A grammar can generate a same string in different ways

**Theorem (context free languages):** The set of languages recognized by pushdown automata $\Leftrightarrow$ the set of languages you can design a CFG to recognize.

### Pushdown Automata

A pushdown automata is a 6-tuple $(Q, \Sigma, \Gamma, \delta, q_0, F)$, where
- $Q$ is finite set of states
- $\Sigma$ is finite input alphabet
- $\Gamma$ is finite stack alphabet
- $$\delta: Q\times \Sigma_{\varepsilon} \times \Gamma_{\varepsilon} \rightarrow \mathcal{P}(Q\times \Gamma_{\varepsilon})$$
- $q_0\in Q$ is the start state
- $F\subseteq Q$ is the set of accept states

**The process of computation by pushdown automata**
$M$ accepts input $w = w_1...w_n$ where $w_i\in \Sigma_{\varepsilon}$ and sequence of states $r_0,...,r_n\in Q$, strings $s_0,...,s_n\in \Gamma^*$ exists with following conditions:
1. $M$ starts with $r_0 = q_0$ and $s_0 = \varepsilon$: with start state and empty stack
2. For $i = 0,...,n-1$, we have $(r_{i+1}, b) \in \delta(r_i, w_{i+1}, a)$: $M$ moves properly according to state, stack and next input symbol
3. $r_n \in F$

"$a, b\rightarrow c$":  when the machine is reading $a$ from the input, replace $b$ on top of stack by a $c$

To test for an empty stack, placing a $\$$ on the stack.

**Equivalence with Context free grammars**

**Corollary:** Every regular language is context free.

#### Pumping lemma for CFLs
**Theorem:** If a language $A$ is CFL, then there is a number $p$ where, if $s$ is any string of $A$ of length at least $p$, $s$ maybe divided into 5 pieces: $s = uvxyz$ satisfying:
1. For each $i\geq 0, uv^ixy^iz\in A$
2. $|vy|$ > 0: **either $v$ or $y$ is not emptyset**
3. $|vxy| \leq p$

*Idea:* Suppose a string $s$ derived from CFG $G$ and has a parse tree. 
Height of parse tree of $s$ is $h$, and $b$ is the maximum number of symbols on the right side of a rule, then length of $s$ is at most $b^h$. The parse tree must contain some path from start variable to one of the terminal symbols at a leaf. $h$ has to be bigger than the number of variables on the path.
Because of pigeonhole principle, some variable symbol $R$ must repeat.

![](pumping_lemma_for_CLFs.png)


**Show a language is context free**
$$V = \{x\in\{a,b\}^* | x \text{ has twice as many a's than b's}\}$$
1. By constructing a context free grammar: 
$$S\rightarrow SS | aaSb | aSbSa | baSa | \varepsilon$$

*Proof by induction:*
**Base Case (n=0 or 3):** 2nd, 3rd, 4th, 5th rules generate aab, aba, baa, $\varepsilon$
**Induction hypothesis:** Suppose all strings in $V$ of length $< 3k$ can be generated
**Induction step:** Let $w$ be a string of length $3k$ in $V$. WTS $w$ can be generated by the CFG
- Case 1: There is a segment of string in $w$, called $w_1$ which is in $V$. $w$ can be partitioned into $w_1$ concatenated with $w_2$, where $w_1$ and $w_2$ are in $V$. $S\rightarrow SS$, by induction hypothesis the first $S$ generates $w_1$ and the second $S$ generates $w_2$.
- Case 2: There is no segment of $w$ that is in $V$. Suppose the last character is $b$, then this $b$ must be counterbalanced by two $a$'s. If the two $a$'s occur before the first two characters, we can split $w$ into $w_1$ and $w_2$ and we are back in case 1.
- Case 3: There is no segment of $w$ that is in $V$. Suppose the last character is $a$, then this $a$ must be counterbalanced by $a$ and $b$, and one of them must be the first character. If $b$ is first then $a$ must be next, $S\rightarrow baSa$. If $a$ is the first then an extra $b$ must be somewhere in the middle: $aw_1bw_2a$, where $w_1, w_2$ are in $V$. Use $S\rightarrow aSbSa$.

---

### HW Problems

**hw2p4**



